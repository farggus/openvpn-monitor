<!DOCTYPE html>

<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>OpenVPN Management panel</title>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
  <link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet"></link>
</head>

<body class="bg-light">
<div class="container mt-5">
<div></div>
  <button class="btn btn-outline-primary me-2" id="mapBtn">Map View</button>
  <button class="btn btn-outline-primary me-2" id="chartsBtn">Charts</button>
  <button class="btn btn-outline-primary me-1" id="historyBtn">Connection history</button>
  <button class="btn btn-outline-secondary" id="themeToggle">Switch Theme</button>  
</div>



<div class="container mt-5">
  <h2>OpenVPN - Serv</h2>
  <div class="table-responsive">
    <table class="table-bordered text-nowrap table table-sm" id="server-status-table">
      <thead class="table-light">
        <tr>
          <th>VPN Mode</th>
          <th>Status</th>
          <th>Pingable</th>
          <th>Clients</th>
          <th>Total Bytes In</th>
          <th>Total Bytes Out</th>
          <th>Up Since</th>
          <th>Local IP</th>
          <th>Public IP</th>
        </tr>
      </thead>
      <tbody id="server-status-body"><tr><td colspan="9">Loading...</td></tr></tbody>
    </table>
  </div>
  
  <h2 class="mb-4">OpenVPN - Clients</h2>
  <div class="table-responsive">
    <table class="table-bordered table table-hover text-nowrap table-sm">
      <thead class="table-light">
        <tr>
          <th>Client</th>
          <th>VPN IPV4</th>
          <th>VPN IPV6</th>
          <th>Client IP</th>
          <th>Port</th>
          <th>Session Opened</th>
          <th>Time Online</th>
          <th>Speed (Rx / Tx)</th>
          <th>Bytes Received</th>
          <th>Bytes Sent</th>
        </tr>
      </thead>
      
      <tbody id="vpn-clients-body"></tbody>
      <tfoot class="table-light">
        <tr>
          <th colspan="8">Total</th>
          <th id="total-received">0 MB</th>
          <th id="total-sent">0 MB</th>
        </tr>
      </tfoot>
    </table>
  </div>
  
  <!--
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div>
      <button class="btn btn-outline-primary me-2" id="toggleGraphBtn">Charts</button>
      <button class="btn btn-outline-primary me-2" id="toggleMapBtn">Map View</button>
      <button class="btn btn-outline-secondary" id="historyBtn">Connection history</button>
    </div>
  </div>

  
  <div class="d-flex justify-content-between align-items-center mb-3">
    <div>
      <button class="btn btn-outline-primary me-2" id="chartsBtn">Charts</button>
      <button class="btn btn-outline-primary me-2" id="mapBtn">Map View</button>
      <button class="btn btn-outline-secondary" id="historyBtn">Connection history</button>
    </div>
  </div>


  <div class="mt-5" id="graph-section" style="display: none;">
    <h2>Traffic Graph (MB/s)</h2>
    <canvas class="w-100" height="100" id="trafficChart"></canvas>
  </div>
  
  <div class="mb-4" id="map-section" style="display:none;">
    <h2>Client Locations</h2>
    <div id="map" style="height: 400px;"></div>
  </div>  
  -->
  
</div>

<!-- History Modal -->
<div aria-hidden="true" class="modal fade" id="historyModal" tabindex="-1">
  <div class="modal-dialog modal-xl modal-dialog-scrollable modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
      <h5 class="modal-title">Connection history</h5>
      <button aria-label="Закрыть" class="btn-close" data-bs-dismiss="modal" type="button"></button>
      </div>
      <div class="modal-body">
        <div class="d-flex align-items-end justify-content-start gap-3 mb-3">
          <div>
            <label class="form-label" for="filterDate">Date</label>
            <input class="form-control" id="filterDate" type="date"/>
          </div>
          <div>
            <label class="form-label" for="filterUser">Client</label>
            <input class="form-control" id="filterUser" list="userList" type="text"/>
            <datalist id="userList"></datalist>
          </div>
          <div class="ms-auto"> <!-- d-flex gap-2 -->
            <button class="btn btn-outline-secondary" id="resetFilters">Clear filter</button>
            <button class="btn btn-outline-success" id="viewOnMap">View on map</button>
          </div>
        </div>
        <div class="table-responsive">
          <table class="table-bordered text-nowrap table table-sm">
            <thead class="table-light">
              <tr>
                <th>Session Opened</th>
                <th>Client</th>
                <th>VPN IPV4</th>
                <th>VPN IPV6</th>
                <th>Client IP</th>
                <th>Port</th>
                <th>Session Closed</th>
                <th>Duration</th>
                <th>Rx (MB)</th>
                <th>Tx (MB)</th>
              </tr>
            </thead>
            <tbody id="history-body"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- Charts (Traffic) Modal -->
<div class="modal fade" id="chartsModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Traffic Charts (MB/s)</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body">
        <canvas id="trafficChartModal" height="120" class="w-100"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- Map View Modal -->
<div class="modal fade" id="mapModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-scrollable modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Client Locations</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Закрыть"></button>
      </div>
      <div class="modal-body">
        <div id="mapModalMap" style="height: 500px;"></div>
      </div>
    </div>
  </div>
</div>

<!-- History - View On Map Modal -->
<div class="modal fade" id="historyMapModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-fullscreen-sm-down">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">History — View on map</h5>
        <button class="btn-close" data-bs-dismiss="modal" aria-label="Close" type="button"></button>
      </div>
      <div class="modal-body p-0">
        <div id="historyMap" style="height: 70vh; width: 100%;"></div>
      </div>
    </div>
  </div>
</div>

<!-- Подключение скриптов -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<!-- Весь JavaScript -->
<script>

// ПЕРЕМЕННЫЕ
let lastStats = {};
let chart = null;
let chartData = { labels: [], datasets: [] };
let fullHistoryData = [];

// Для карты в модалке
let mapInitialized = false;
let mapInstance;
let mapMarkers = [];
const geoCache = {};

// Отдельный реф на canvas в модалке
let chartCanvas = null;

// ИНИЦИАЛИЗАЦИЯ
document.addEventListener("DOMContentLoaded", function () {
  const refreshAll = () => {
    fetchData();
    fetchServerStatus();
  };

  refreshAll();
  setInterval(refreshAll, 1000);
  
  /*
  document.getElementById("toggleGraphBtn").addEventListener("click", () => {
    const graphSection = document.getElementById("graph-section");
    graphSection.style.display = graphSection.style.display === "none" ? "block" : "none";
  }); 
  

  document.getElementById("toggleMapBtn").addEventListener("click", () => {
    const section = document.getElementById("map-section");
    const shown = section.style.display === "block";
    section.style.display = shown ? "none" : "block";
    

    if (!mapInitialized && !shown) {
        mapInstance = L.map('map').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: 'Map data © OpenStreetMap contributors'
        }).addTo(mapInstance);
        mapInitialized = true;
      }
      if (!shown) loadClientMarkers();
  });
  */
document.getElementById("themeToggle").addEventListener("click", toggleTheme);  
  
document.getElementById("chartsBtn").addEventListener("click", () => {
  const chartsModalEl = document.getElementById('chartsModal');
  const chartsModal = new bootstrap.Modal(chartsModalEl);
  chartsModal.show();
});

// при открытии модалки — создаём/обновляем график
document.getElementById('chartsModal').addEventListener('shown.bs.modal', () => {
  chartCanvas = document.getElementById('trafficChartModal');
  if (!chart) {
    // chart будет инициализирован лениво при первом fetchData(), когда появятся клиенты
    // но нужно форснуть один fetch для гарантии
    fetchData(true);
  } else {
    chart.resize();
    chart.update();
  }
});

document.getElementById("mapBtn").addEventListener("click", () => {
  const mapModalEl = document.getElementById('mapModal');
  const mapModal = new bootstrap.Modal(mapModalEl);
  mapModal.show();
});

// при открытии модалки — создаём карту и грузим маркеры
document.getElementById('mapModal').addEventListener('shown.bs.modal', () => {
  if (!mapInitialized) {
    mapInstance = L.map('mapModalMap').setView([20, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Map data © OpenStreetMap contributors'
    }).addTo(mapInstance);
    mapInitialized = true;
  } else {
    mapInstance.invalidateSize();
  }
  loadClientAndServerMarkers();
});

document.getElementById("historyBtn").addEventListener("click", () => {
  $.getJSON("/api/history", function (entries) {
    if (!Array.isArray(entries)) return alert("Ошибка: " + (entries.error || "Не удалось загрузить историю"));
    fullHistoryData = entries.filter(e => e.rx !== null && e.tx !== null);
    const names = [...new Set(fullHistoryData.map(e => e.name))];
    document.getElementById("userList").innerHTML = names.map(n => `<option value="${n}">`).join("");
    document.getElementById("filterDate").value = new Date().toISOString().split('T')[0];
    applyFilters();
    new bootstrap.Modal(document.getElementById('historyModal')).show();
  }).fail(() => alert("Ошибка при запросе к серверу"));
});
  
  document.getElementById("filterDate").addEventListener("input", applyFilters);
  document.getElementById("filterUser").addEventListener("input", applyFilters);
  document.getElementById("resetFilters").addEventListener("click", () => {
    document.getElementById("filterDate").value = "";
    document.getElementById("filterUser").value = "";
    renderHistoryTable(fullHistoryData);
  });
});

// ФУНКЦИИ
function toggleTheme() {
  const isDark = document.body.classList.contains("bg-dark");
  const toggle = (sel, darkClass, lightClass) => {
    document.querySelectorAll(sel).forEach(el => {
      el.classList.toggle(darkClass, !isDark);
      el.classList.toggle(lightClass, isDark);
    });
  };

  document.body.classList.toggle("bg-dark", !isDark);
  document.body.classList.toggle("bg-light", isDark);

  toggle("table", "table-dark", "table-light");
  toggle("thead", "table-dark", "table-light");
  toggle("tfoot", "table-dark", "table-light");

  // Таблицы и модалки
  toggle(".modal-content, .modal-header, .modal-body", "bg-dark", "bg-light");
  toggle(".modal-content, .modal-header, .modal-body", "text-light", "text-dark");

  // Текстовые заголовки и подписи
  toggle("h1, h2, h3, h4, h5, h6, th, label, button", "text-light", "text-dark");

  // Инпуты и выпадашки
  toggle("input, select, textarea", "bg-dark", "bg-light");
  toggle("input, select, textarea", "text-light", "text-dark");
  toggle("input, select, textarea", "border-light", "border-dark");

  // Выпадающие списки, календарь
  setTimeout(() => {
    toggle(".dropdown-menu, .select2-dropdown, datalist, .datepicker, .flatpickr-calendar, .ui-datepicker", "bg-dark", "bg-light");
    toggle(".dropdown-menu, .select2-dropdown, datalist, .datepicker, .flatpickr-calendar, .ui-datepicker", "text-light", "text-dark");
  }, 100);
}


function formatUptime(uptimeStr) {
  const uptime = new Date(uptimeStr);
  const now = new Date();
  const diffMs = now - uptime;
  if (isNaN(uptime.getTime()) || diffMs < 0) return "Unknown";
  const minutes = Math.floor(diffMs / 60000);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  return `${days > 0 ? days + "d " : ""}${hours % 24}h ${minutes % 60}m`;
}

function fetchServerStatus() {
  fetch("/api/server-status")
    .then(r => r.json())
    .then(data => {
      const row = `<tr>
        <td>${data.mode}</td><td>${data.status}</td><td>${data.pingable}</td>
        <td>${data.clients}</td><td>${data.total_rx} MB</td><td>${data.total_tx} MB</td>
        <td>${formatUptime(data.uptime)}</td><td>${data.local_ip}</td><td>${data.public_ip}</td>
      </tr>`;
      document.getElementById("server-status-body").innerHTML = row;
    });
}

function loadClientAndServerMarkers() {
  // очистка
  mapMarkers.forEach(m => mapInstance.removeLayer(m));
  mapMarkers = [];
  const bounds = [];

  // 1) Клиенты
  fetch("/api/clients")
    .then(res => res.json())
    .then(data => {
      const clients = data.clients || [];
      clients.forEach(c => {
        const ip = c.real_ip;
        if (!ip) return;

        const onLoc = (loc) => {
          if (!loc || !loc.latitude || !loc.longitude) return;
          const marker = L.marker([loc.latitude, loc.longitude])
            .addTo(mapInstance)
            .bindPopup(`<strong>${c.common_name}</strong><br>${loc.city || ''} ${loc.country_name || ''}`);
          mapMarkers.push(marker);
          bounds.push([loc.latitude, loc.longitude]);
        };

        if (geoCache[ip]) {
          onLoc(geoCache[ip]);
        } else {
          fetch(`https://ipapi.co/${ip}/json/`)
            .then(r => r.json())
            .then(loc => { geoCache[ip] = loc; onLoc(loc); })
            .catch(() => {});
        }
      });
    })
    .finally(() => {
      // 2) Сервер (красный маркер только если pingable = true)
      fetch("/api/server-status")
        .then(r => r.json())
        .then(s => {
          // в API уже есть pingable и public_ip — используем их
          if (!s || !s.pingable || !s.public_ip) return;

          const serverIp = s.public_ip;
          const placeServer = (loc) => {
            if (!loc || !loc.latitude || !loc.longitude) return;
            // красный "маркер" — используем circleMarker, чтобы не тянуть внешние иконки
            const serverMarker = L.circleMarker([loc.latitude, loc.longitude], {
              radius: 8,
              color: 'red',
              fillColor: 'red',
              fillOpacity: 0.8,
              weight: 2
            })
            .addTo(mapInstance)
            .bindPopup(`<strong>OpenVPN Server</strong><br>${serverIp}`);
            mapMarkers.push(serverMarker);
            bounds.push([loc.latitude, loc.longitude]);

            if (bounds.length) {
              mapInstance.fitBounds(bounds, { padding: [30, 30] });
            }
          };

          if (geoCache[serverIp]) {
            placeServer(geoCache[serverIp]);
          } else {
            fetch(`https://ipapi.co/${serverIp}/json/`)
              .then(r => r.json())
              .then(loc => { geoCache[serverIp] = loc; placeServer(loc); })
              .catch(() => {});
          }
        })
        .finally(() => {
          if (bounds.length) {
            mapInstance.fitBounds(bounds, { padding: [30, 30] });
          }
        });
    });
}



function addMarker(loc, client, bounds) {
  const marker = L.marker([loc.latitude, loc.longitude])
    .addTo(mapInstance)
    .bindPopup(`<strong>${client.common_name}</strong><br>${loc.city}, ${loc.country_name}`);
  mapMarkers.push(marker);
  bounds.push([loc.latitude, loc.longitude]);
  mapInstance.fitBounds(bounds, { padding: [30, 30] });
}


function applyFilters() {
  const dateFilter = document.getElementById("filterDate").value;
  const userFilter = document.getElementById("filterUser").value.toLowerCase();
  const filtered = fullHistoryData.filter(e =>
    (!dateFilter || e.timestamp.startsWith(dateFilter)) &&
    (!userFilter || e.name.toLowerCase().includes(userFilter))
  );
  renderHistoryTable(filtered);
}

function renderHistoryTable(data) {
  const rows = data.map(e => {
    const legacyVpnIp = e.vpn_ip ?? "";
    const vpnIpv4 = e.vpn_ipv4 || (legacyVpnIp && legacyVpnIp.includes('.') ? legacyVpnIp : "");
    const rawIpv6 = e.vpn_ipv6 || (legacyVpnIp && legacyVpnIp.includes(':') ? legacyVpnIp : "");
    const vpnIpv6 = rawIpv6 || "—";

    return `
      <tr>
        <td>${e.timestamp}</td><td>${e.name}</td><td>${vpnIpv4}</td><td>${vpnIpv6}</td><td>${e.ip}</td>
        <td>${e.port ?? ""}</td><td>${e.session_end ?? ""}</td>
        <td>${e.duration ?? ""}</td><td>${e.rx ?? ""}</td><td>${e.tx ?? ""}</td>
      </tr>
    `;
  }).join("");
  document.getElementById("history-body").innerHTML = rows;
}

function fetchData(forceInitChart = false) {
  $.getJSON("/api/clients", function(data) {
    const now = Date.now();
    const timeLabel = new Date().toLocaleTimeString();
    let total_received = 0, total_sent = 0;
    const clients = data.clients || [];
    let users = clients.map(c => c.common_name);

    // Инициализация/переинициализация графика (теперь в модалке)
    if (forceInitChart || !chart || chartData.datasets.length !== users.length * 2) {
      if (!chart && !chartCanvas) {
        // Если модалка ещё не открыта — пока откладываем
      } else {
        if (chart) chart.destroy();
        chartData = { labels: [], datasets: [] };
        const colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown'];
        users.forEach((user, i) => {
          chartData.datasets.push(
            { label: `${user} Rx`, data: [], borderColor: colors[i % colors.length], fill: false },
            { label: `${user} Tx`, data: [], borderColor: colors[(i + 1) % colors.length], borderDash: [5,5], fill: false }
          );
        });
        if (chartCanvas) {
          chart = new Chart(chartCanvas, {
            type: 'line',
            data: chartData,
            options: { responsive: true, animation: false }
          });
        }
      }
    }

    // labels
    if (chartData.labels) {
      chartData.labels.push(timeLabel);
      if (chartData.labels.length > 20) chartData.labels.shift();
    }

    const datasetMap = chartData.datasets ? Object.fromEntries(chartData.datasets.map(ds => [ds.label, ds.data])) : {};

    const rows = clients.map(client => {
      total_received += client.bytes_received;
      total_sent += client.bytes_sent;

      let speed_rx = 0, speed_tx = 0;
      const last = lastStats[client.common_name];
      if (last) {
        const dt = (now - last.timestamp) / 1000;
        speed_rx = (client.bytes_received - last.rx) / dt / 1024 / 1024;
        speed_tx = (client.bytes_sent - last.tx) / dt / 1024 / 1024;
      }

      lastStats[client.common_name] = {
        rx: client.bytes_received,
        tx: client.bytes_sent,
        timestamp: now
      };

      if (datasetMap[`${client.common_name} Rx`]) {
        datasetMap[`${client.common_name} Rx`].push(speed_rx);
        if (datasetMap[`${client.common_name} Rx`].length > 20) datasetMap[`${client.common_name} Rx`].shift();
      }
      if (datasetMap[`${client.common_name} Tx`]) {
        datasetMap[`${client.common_name} Tx`].push(speed_tx);
        if (datasetMap[`${client.common_name} Tx`].length > 20) datasetMap[`${client.common_name} Tx`].shift();
      }

      const ipv4Candidate = client.vpn_ipv4 ?? null;
      const ipv6Candidate = client.vpn_ipv6 ?? null;

      let vpnIPv4 = ipv4Candidate;
      let vpnIPv6 = ipv6Candidate;

      if (vpnIPv4 == null && vpnIPv6 == null && client.vpn_ip) {
        if (client.vpn_ip.includes(':')) {
          vpnIPv6 = client.vpn_ip;
        } else {
          vpnIPv4 = client.vpn_ip;
        }
      }

      const displayIPv4 = vpnIPv4 ?? "";
      const displayIPv6 = vpnIPv6 && vpnIPv6.trim() ? vpnIPv6 : "—";

      return `<tr>
        <td>${client.common_name}</td><td>${displayIPv4}</td><td>${displayIPv6}</td><td>${client.real_ip}</td><td>${client.port ?? ""}</td>
        <td>${client.connected_since}</td><td>${client.time_online}</td>
        <td>${speed_rx.toFixed(2)} / ${speed_tx.toFixed(2)} MB/s</td>
        <td>${(client.bytes_received / 1024 / 1024).toFixed(2)} MB</td>
        <td>${(client.bytes_sent / 1024 / 1024).toFixed(2)} MB</td>
      </tr>`;
    }).join("");

    $("#vpn-clients-body").html(rows);
    $("#total-received").text((total_received / 1024 / 1024).toFixed(2) + " MB");
    $("#total-sent").text((total_sent / 1024 / 1024).toFixed(2) + " MB");

    if (chart) chart.update();
  });
}
</script>

<script>
// === History -> View on map ===
// Требования: Bootstrap 5, Leaflet; модалка истории уже существует (таблица с <thead>/<tbody>)

(function(){
  // Возьмём (или создадим) общий кэш геолокаций
  const globalAny = window;
  const geoCache = globalAny.geoCache = globalAny.geoCache || {};

  let historyMapInitialized = false;
  let historyMapInstance;
  let historyMapMarkers = [];

  // Найти контейнер кнопок в модалке истории; добавить туда кнопку, если её нет
  function ensureViewOnMapButton() {
    const viewBtnId = 'viewOnMap';
    if (document.getElementById(viewBtnId)) return;

    // ищем рядом с resetFilters
    const resetBtn = document.getElementById('resetFilters');
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'btn btn-outline-success';
    btn.id = viewBtnId;
    btn.textContent = 'View on map';

    if (resetBtn && resetBtn.parentElement) {
      resetBtn.parentElement.appendChild(btn);
    } else {
      // fallback: вставим в модалку истории в правый верхний угол
      const historyModal = document.getElementById('historyModal');
      if (historyModal) {
        const hdr = historyModal.querySelector('.modal-header');
        if (hdr) hdr.appendChild(btn);
      } else {
        // если совсем ничего не нашли — добавим в body (редкий случай)
        document.body.appendChild(btn);
      }
    }
  }

  // Получаем IP-адреса из текущей видимой таблицы истории (учитываются фильтры, т.к. читаем DOM)
  function collectVisibleHistoryIPs() {
    // Находим модалку истории и таблицу
    const historyModal = document.getElementById('historyModal') || document;
    const table = historyModal.querySelector('table');
    if (!table) return [];

    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody') || table.querySelector('#history-body');
    if (!thead || !tbody) return [];

    // Определяем индекс колонки "Client IP" по тексту заголовка
    const headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
    let ipCol = headers.findIndex(h => h === 'client ip' || h.includes('client ip'));
    if (ipCol === -1) {
      // fallback: попробуем найти "ip" одно слово
      ipCol = headers.findIndex(h => h === 'ip' || h.endsWith(' ip'));
    }
    if (ipCol === -1) return [];

    // Берём все видимые строки и собираем IP из нужной колонки
    const ips = new Set();
    const rows = Array.from(tbody.querySelectorAll('tr'));
    rows.forEach(tr => {
      // если строка скрыта CSS (display:none) — пропускаем
      const style = window.getComputedStyle(tr);
      if (style.display === 'none' || style.visibility === 'hidden') return;

      const cells = tr.children;
      if (!cells || cells.length <= ipCol) return;
      const ip = (cells[ipCol].textContent || '').trim();
      if (ip) ips.add(ip);
    });

    return Array.from(ips);
  }

  function openHistoryMap() {
    // Собираем уникальные IP из видимой таблицы
    const uniqueIPs = collectVisibleHistoryIPs();
    if (uniqueIPs.length === 0) {
      alert('Нет записей для отображения на карте (проверьте фильтры).');
      return;
    }

    // Показываем или инициализируем модал с картой
    const modalEl = document.getElementById('historyMapModal');
    if (!modalEl) {
      alert('Карта для истории не найдена в HTML (добавь модалку #historyMapModal из инструкции).');
      return;
    }
    const modal = bootstrap && bootstrap.Modal ? new bootstrap.Modal(modalEl) : null;
    if (modal) modal.show();

    if (!historyMapInitialized) {
      historyMapInstance = L.map('historyMap').setView([20, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Map data © OpenStreetMap contributors'
      }).addTo(historyMapInstance);
      historyMapInitialized = true;

      // Когда модал показан — пересчёт размеров карты
      modalEl.addEventListener('shown.bs.modal', () => {
        setTimeout(() => historyMapInstance.invalidateSize(), 50);
      });
    }

    // Чистим предыдущие маркеры
    historyMapMarkers.forEach(m => historyMapInstance.removeLayer(m));
    historyMapMarkers = [];
    const bounds = [];

    // Рисуем зелёные circleMarker
    const addGreen = (lat, lon, label) => {
      const m = L.circleMarker([lat, lon], {
        radius: 8,
        color: '#2e7d32',
        weight: 2,
        fillColor: '#43a047',
        fillOpacity: 0.9
      }).addTo(historyMapInstance).bindPopup(label);
      historyMapMarkers.push(m);
      bounds.push([lat, lon]);
    };

    // Геолокация IP (с кешированием)
    uniqueIPs.forEach(ip => {
      if (geoCache[ip]) {
        const loc = geoCache[ip];
        if (loc && loc.latitude && loc.longitude) {
          addGreen(loc.latitude, loc.longitude, `${ip}<br>${loc.city ?? ''} ${loc.country_name ?? ''}`);
          if (bounds.length) historyMapInstance.fitBounds(bounds, { padding: [30,30] });
        }
        return;
      }
      fetch(`https://ipapi.co/${encodeURIComponent(ip)}/json/`)
        .then(r => r.json())
        .then(loc => {
          if (!loc || !loc.latitude || !loc.longitude) return;
          geoCache[ip] = loc;
          addGreen(loc.latitude, loc.longitude, `${ip}<br>${loc.city ?? ''} ${loc.country_name ?? ''}`);
          if (bounds.length) historyMapInstance.fitBounds(bounds, { padding: [30,30] });
        })
        .catch(err => console.error('History geo fetch error:', err));
    });
  }

  // Хук на кнопку
  function bindButton() {
    const btn = document.getElementById('viewOnMap');
    if (btn && !btn.dataset._bound) {
      btn.addEventListener('click', openHistoryMap);
      btn.dataset._bound = '1';
    }
  }

  // Если модалка истории открывается по кнопке, удобно вешаться на её показ:
  // но не у всех разметка одинаковая, поэтому делаем универсально:
  document.addEventListener('click', (e) => {
    const t = e.target;
    // Поймаем открытие истории, если у кнопки есть id вида 'historyBtn' или текст содержит 'Connection history'
    if (t && (t.id === 'historyBtn' || /connection history/i.test(t.textContent || ''))) {
      // немножко подождём, пока модалка отрендерит таблицу
      setTimeout(() => { ensureViewOnMapButton(); bindButton(); }, 150);
    }
  });

  // На всякий случай — при загрузке тоже попробуем:
  document.addEventListener('DOMContentLoaded', () => {
    ensureViewOnMapButton();
    bindButton();
    // если модалка карты уже есть — добавим invalidateSize на показ (на случай программного открытия)
    const historyMapModalEl = document.getElementById('historyMapModal');
    if (historyMapModalEl) {
      historyMapModalEl.addEventListener('shown.bs.modal', () => {
        if (historyMapInitialized) historyMapInstance.invalidateSize();
      });
    }
  });
})();

</script>

<script>
// ====== Robust Geo + History Map Refresh Patch (drop-in) ======
// Делает: устойчивый геокод, персистентный кэш, корректный fitBounds, авто-обновление карты истории при смене фильтров.

// ---- Persistent geo cache (RAM + localStorage) ----
(function(){
  const LS_KEY = 'ovpnGeoCacheV1';
  const TTL_DAYS = 30;

  const memCache = window.geoCache || {}; // переиспользуем, если уже есть
  let lsCache = {};
  try { lsCache = JSON.parse(localStorage.getItem(LS_KEY) || '{}'); } catch {}

  function nowSec(){ return Math.floor(Date.now()/1000); }
  function ttlSec(){ return TTL_DAYS*24*3600; }

  function readCache(ip){
    if (memCache[ip]) return memCache[ip];
    const e = lsCache[ip];
    if (!e) return null;
    if ((nowSec() - (e.t||0)) > ttlSec()) { delete lsCache[ip]; return null; }
    memCache[ip] = e.v;
    return e.v;
  }
  function writeCache(ip, val){
    memCache[ip] = val;
    lsCache[ip] = { v: val, t: nowSec() };
    try { localStorage.setItem(LS_KEY, JSON.stringify(lsCache)); } catch {}
  }

  // ---- Geo providers (primary + fallback) ----
  async function geoIpApi(ip){
    const r = await fetch(`https://ipapi.co/${encodeURIComponent(ip)}/json/`, {cache:'no-store'});
    const j = await r.json();
    if (!j || !j.latitude || !j.longitude) throw new Error('ipapi no lat/lon');
    return { lat: j.latitude, lon: j.longitude, city: j.city || '', country: j.country_name || '' };
  }
  async function geoIpWho(ip){
    const r = await fetch(`https://ipwho.is/${encodeURIComponent(ip)}`, {cache:'no-store'});
    const j = await r.json();
    if (!j || j.success !== true || !j.latitude || !j.longitude) throw new Error('ipwho fail');
    return { lat: j.latitude, lon: j.longitude, city: j.city || '', country: j.country || '' };
  }

  async function geocodeIP(ip){
    const cached = readCache(ip);
    if (cached) return cached;
    let g;
    try { g = await geoIpApi(ip); }
    catch { g = await geoIpWho(ip); }
    writeCache(ip, g);
    return g;
  }

  // ---- MAIN MAP hardening (если у тебя есть live-карта клиентов) ----
  if (typeof window.loadClientMarkers === 'function') {
    const _origLoad = window.loadClientMarkers;
    window.loadClientMarkers = function(){
      // Переопределим добавление маркеров так, чтобы оно ждало геокод
      try {
        fetch("/api/clients")
          .then(res => res.json())
          .then(async data => {
            if (!window.mapInstance) return;
            // Снимем старые
            (window.mapMarkers||[]).forEach(m => window.mapInstance.removeLayer(m));
            window.mapMarkers = [];
            const bounds = [];
            for (const c of (data.clients||[])) {
              const ip = c.real_ip;
              if (!ip) continue;
              try {
                const loc = await geocodeIP(ip);
                const m = L.marker([loc.lat, loc.lon])
                  .addTo(window.mapInstance)
                  .bindPopup(`<strong>${c.common_name}</strong><br>${loc.city}, ${loc.country}`);
                window.mapMarkers.push(m);
                bounds.push([loc.lat, loc.lon]);
              } catch(e){}
            }
            if (bounds.length) window.mapInstance.fitBounds(bounds, { padding: [30,30] });
          });
      } catch(e) { _origLoad(); }
    }
  }

  // ---- HISTORY MAP: re-read table after filters; wait for geocodes; then fitBounds ----
  (function(){
    let historyMapInstance = null;
    let historyMapInitialized = false;
    let historyMapMarkers = [];

    function ensureButton(){
      if (document.getElementById('viewOnMap')) return;
      const reset = document.getElementById('resetFilters');
      const btn = document.createElement('button');
      btn.id = 'viewOnMap';
      btn.type = 'button';
      btn.className = 'btn btn-outline-success';
      btn.textContent = 'View on map';
      if (reset && reset.parentElement) reset.parentElement.appendChild(btn);
      else document.body.appendChild(btn);
    }

    // Найти текущие видимые IP из таблицы истории
    function collectIPsFromHistoryTable(){
      const modal = document.getElementById('historyModal') || document;
      const table = modal.querySelector('table');
      if (!table) return [];
      const thead = table.querySelector('thead');
      const tbody = table.querySelector('tbody') || table.querySelector('#history-body');
      if (!thead || !tbody) return [];
      const headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim().toLowerCase());
      let ipCol = headers.findIndex(h => h === 'client ip' || h.includes('client ip'));
      if (ipCol === -1) ipCol = headers.findIndex(h => h === 'ip' || h.endsWith(' ip'));
      if (ipCol === -1) return [];
      const ips = new Set();
      for (const tr of Array.from(tbody.querySelectorAll('tr'))) {
        const s = getComputedStyle(tr);
        if (s.display === 'none' || s.visibility === 'hidden') continue;
        const td = tr.children[ipCol];
        if (!td) continue;
        const ip = (td.textContent||'').trim();
        if (ip) ips.add(ip);
      }
      return Array.from(ips);
    }

    async function buildHistoryMap(){
      const modalEl = document.getElementById('historyMapModal');
      if (!modalEl) { alert('Добавь модал #historyMapModal в HTML'); return; }

      // Соберём IP на момент клика (учтены текущие фильтры, т.к. читаем DOM)
      const ips = collectIPsFromHistoryTable();
      // Если фильтр «съел» все строки — предупреждаем
      if (ips.length === 0) {
        alert('Нет записей для отображения на карте. Измени фильтры.');
        return;
      }

      // Показать модал
      const modal = new bootstrap.Modal(modalEl);
      modal.show();

      // Инициализировать карту один раз
      if (!historyMapInitialized) {
        historyMapInstance = L.map('historyMap').setView([20, 0], 2);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: 'Map data © OpenStreetMap contributors'
        }).addTo(historyMapInstance);
        modalEl.addEventListener('shown.bs.modal', () => {
          setTimeout(() => historyMapInstance.invalidateSize(), 50);
        });
        historyMapInitialized = true;
      }

      // Очистка старых маркеров
      historyMapMarkers.forEach(m => historyMapInstance.removeLayer(m));
      historyMapMarkers = [];

      // Геокодируем пачкой и потом делаем fitBounds
      const bounds = [];
      const addGreen = (lat, lon, label) => {
        const m = L.circleMarker([lat, lon], {
          radius: 8, color: '#2e7d32', weight: 2, fillColor: '#43a047', fillOpacity: 0.9
        }).addTo(historyMapInstance).bindPopup(label);
        historyMapMarkers.push(m);
        bounds.push([lat, lon]);
      };

      const results = await Promise.allSettled(ips.map(async ip => {
        const g = await geocodeIP(ip);
        addGreen(g.lat, g.lon, `${ip}<br>${g.city} ${g.country}`);
      }));

      // Если все геокоды упали — дёрнем фолбэк‑сообщение
      const ok = results.some(r => r.status === 'fulfilled');
      if (!ok) {
        alert('Не удалось получить геолокацию IP (лимиты/сеть). Повтори позже.');
        return;
      }
      if (bounds.length) historyMapInstance.fitBounds(bounds, { padding: [30,30] });
    }

    // При любом изменении фильтров, если карта открыта — можно пересобрать (опционально):
    function historyMapIsOpen(){
      const el = document.getElementById('historyMapModal');
      return el && el.classList.contains('show');
    }
    function tryRefreshOpenHistoryMap(){
      if (historyMapIsOpen()) buildHistoryMap();
    }

    // Навесим: создание кнопки, клик по кнопке, и авто‑рефреш при фильтрах
    function bind(){
      ensureButton();
      const btn = document.getElementById('viewOnMap');
      if (btn && !btn.dataset._bound) {
        btn.addEventListener('click', buildHistoryMap);
        btn.dataset._bound = '1';
      }
      const fd = document.getElementById('filterDate');
      const fu = document.getElementById('filterUser');
      const rf = document.getElementById('resetFilters');
      [fd, fu].forEach(el => el && el.addEventListener('input', () => {
        // Дадим DOM перерисоваться и переснимем IP
        setTimeout(tryRefreshOpenHistoryMap, 120);
      }));
      rf && rf.addEventListener('click', () => setTimeout(tryRefreshOpenHistoryMap, 150));
    }

    document.addEventListener('DOMContentLoaded', bind);
    // На случай программного открытия модалки истории:
    document.addEventListener('click', (e) => {
      if (e.target && (e.target.id === 'historyBtn' || /connection history/i.test(e.target.textContent||''))) {
        setTimeout(bind, 150);
      }
    });
  })();
})();
</script>


</body>
</html>
